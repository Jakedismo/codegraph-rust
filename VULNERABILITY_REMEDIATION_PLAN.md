# CodeGraph Vulnerability Remediation Plan

**Date**: 2025-01-09  
**Version**: 1.0  
**Priority**: CRITICAL - Production Blocker  
**Estimated Duration**: 4 weeks  

## Executive Summary

This document provides detailed remediation strategies for the **10 security vulnerabilities** identified in the CodeGraph security audit. The plan is organized by priority level and includes specific implementation steps, testing requirements, and success criteria.

**‚ö†Ô∏è PRODUCTION DEPLOYMENT BLOCKED**: Critical vulnerabilities must be resolved before any production deployment.

## Critical Vulnerabilities Remediation (Week 1)

### üî¥ CVE-2024-0437: Dependency Vulnerability Fix

**Target**: RUSTSEC-2024-0437 protobuf recursion DoS  
**Priority**: P0 - Critical  
**Effort**: 4 hours  

#### Implementation Steps
1. **Update Cargo.toml to force secure protobuf version**:
```toml
# Add to [patch.crates-io] section
[patch.crates-io]
protobuf = "3.7.2"  # Force secure version across all dependencies
```

2. **Update Cargo.lock**:
```bash
cargo update protobuf
cargo audit  # Verify fix
```

3. **Test compatibility**:
```bash
cargo build --all-features
cargo test --all
```

#### Success Criteria
- [ ] `cargo audit` reports no vulnerabilities for protobuf
- [ ] All tests pass with updated dependency
- [ ] Prometheus metrics continue to function correctly

---

### üî¥ SEC-001: Secure JWT Secret Management

**Target**: Replace hardcoded JWT secret  
**Priority**: P0 - Critical  
**Effort**: 1 day  

#### Implementation Steps

1. **Create secure configuration structure**:
```rust
// In crates/codegraph-core/src/config.rs
use secrecy::{ExposeSecret, Secret};
use serde::Deserialize;

#[derive(Deserialize, Clone)]
pub struct AuthConfig {
    pub jwt_secret: Secret<String>,
    pub jwt_expiry_hours: u64,
}

impl AuthConfig {
    pub fn from_env() -> Result<Self, ConfigError> {
        Ok(Self {
            jwt_secret: Secret::new(
                std::env::var("JWT_SECRET")
                    .map_err(|_| ConfigError::MissingEnvVar("JWT_SECRET"))?
            ),
            jwt_expiry_hours: std::env::var("JWT_EXPIRY_HOURS")
                .unwrap_or_else(|_| "24".to_string())
                .parse()
                .map_err(ConfigError::InvalidConfig)?,
        })
    }
}
```

2. **Update authentication middleware**:
```rust
// In crates/codegraph-api/src/auth.rs
use codegraph_core::ConfigManager;
use secrecy::ExposeSecret;

pub async fn auth_middleware(
    State(state): State<Arc<AppState>>,
    mut req: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    // ... existing code ...
    
    if let Some(token) = token {
        let config = state.config.auth();
        let decoding_key = DecodingKey::from_secret(
            config.jwt_secret.expose_secret().as_bytes()
        );
        
        // ... rest of validation
    }
}
```

3. **Environment variable setup**:
```bash
# .env.example
JWT_SECRET=generate_secure_random_secret_here_minimum_32_characters
JWT_EXPIRY_HOURS=24
```

4. **Add secret generation utility**:
```rust
// scripts/generate-jwt-secret.rs
use base64::{Engine as _, engine::general_purpose};
use chacha20poly1305::{Key, XChaCha20Poly1305};

fn main() {
    let key = Key::generate(&mut rand::thread_rng());
    let secret = general_purpose::STANDARD.encode(&key);
    println!("JWT_SECRET={}", secret);
}
```

#### Success Criteria
- [ ] JWT secret loaded from environment variable
- [ ] No hardcoded secrets in source code
- [ ] Authentication tests pass with new configuration
- [ ] Secret generation script available

---

### üî¥ SEC-002: API Key Management System

**Target**: Replace hardcoded API key  
**Priority**: P0 - Critical  
**Effort**: 2 days  

#### Implementation Steps

1. **Design API key storage structure**:
```rust
// In crates/codegraph-core/src/auth.rs
use uuid::Uuid;
use chrono::{DateTime, Utc};
use dashmap::DashMap;

#[derive(Debug, Clone)]
pub struct ApiKey {
    pub id: Uuid,
    pub key_hash: String,
    pub name: String,
    pub permissions: Vec<Permission>,
    pub created_at: DateTime<Utc>,
    pub expires_at: Option<DateTime<Utc>>,
    pub last_used: Option<DateTime<Utc>>,
    pub is_active: bool,
}

pub struct ApiKeyManager {
    keys: DashMap<String, ApiKey>,
}

impl ApiKeyManager {
    pub fn new() -> Self {
        Self {
            keys: DashMap::new(),
        }
    }
    
    pub fn create_key(&self, name: String, permissions: Vec<Permission>) -> (String, Uuid) {
        let key_value = generate_secure_key();
        let key_hash = hash_api_key(&key_value);
        let api_key = ApiKey {
            id: Uuid::new_v4(),
            key_hash: key_hash.clone(),
            name,
            permissions,
            created_at: Utc::now(),
            expires_at: None,
            last_used: None,
            is_active: true,
        };
        
        self.keys.insert(key_hash, api_key.clone());
        (key_value, api_key.id)
    }
    
    pub fn validate_key(&self, key: &str) -> Option<ApiKey> {
        let key_hash = hash_api_key(key);
        self.keys.get(&key_hash).map(|entry| {
            let mut api_key = entry.value().clone();
            api_key.last_used = Some(Utc::now());
            api_key
        })
    }
}

fn generate_secure_key() -> String {
    use base64::{Engine as _, engine::general_purpose};
    let mut key_bytes = [0u8; 32];
    getrandom::getrandom(&mut key_bytes).unwrap();
    format!("cgk_{}", general_purpose::URL_SAFE_NO_PAD.encode(&key_bytes))
}

fn hash_api_key(key: &str) -> String {
    use sha2::{Sha256, Digest};
    let mut hasher = Sha256::new();
    hasher.update(key.as_bytes());
    format!("{:x}", hasher.finalize())
}
```

2. **Update authentication middleware**:
```rust
// In crates/codegraph-api/src/auth.rs
async fn api_key_auth(
    api_key: &str,
    req: &mut Request,
    state: &AppState,
    next: Next,
) -> Result<Response, StatusCode> {
    if let Some(key_info) = state.api_key_manager.validate_key(api_key) {
        if key_info.is_active && key_info.expires_at.map_or(true, |exp| exp > Utc::now()) {
            let auth_context = AuthContext {
                user_id: key_info.id,
                username: format!("api-key-{}", key_info.name),
                permissions: key_info.permissions,
                roles: vec!["api-key".to_string()],
                organization_id: None,
                project_access: vec![],
                session_id: key_info.id.to_string(),
                issued_at: key_info.created_at,
                expires_at: key_info.expires_at.unwrap_or_else(|| Utc::now() + chrono::Duration::days(365)),
            };
            req.extensions_mut().insert(auth_context);
            return Ok(next.run(req).await);
        }
    }
    Err(StatusCode::UNAUTHORIZED)
}
```

3. **Add API key management endpoints**:
```rust
// New endpoints in handlers.rs
#[derive(Deserialize)]
pub struct CreateApiKeyRequest {
    pub name: String,
    pub permissions: Vec<Permission>,
}

pub async fn create_api_key(
    State(state): State<AppState>,
    auth: AuthContext,
    Json(request): Json<CreateApiKeyRequest>,
) -> ApiResult<Json<serde_json::Value>> {
    // Verify admin permissions
    if !AuthorizationEngine::has_permission(&auth, &[Permission::ADMIN_SYSTEM]) {
        return Err(ApiError::Forbidden);
    }
    
    let (key_value, key_id) = state.api_key_manager.create_key(
        request.name,
        request.permissions
    );
    
    Ok(Json(serde_json::json!({
        "key_id": key_id,
        "api_key": key_value,
        "message": "Store this key securely - it won't be shown again"
    })))
}
```

#### Success Criteria
- [ ] API keys stored securely with hashing
- [ ] Key generation and validation working
- [ ] Management endpoints for key lifecycle
- [ ] No hardcoded keys in source code

---

## Major Issues Remediation (Weeks 2-3)

### üü° SEC-003: Fix Rate Limiting Implementation

**Target**: Functional rate limiting system  
**Priority**: P1 - High  
**Effort**: 1 day  

#### Implementation Steps

1. **Fix rate limiting signature**:
```rust
// In crates/codegraph-api/src/auth.rs
impl RateLimitManager {
    pub fn check_rate_limit(&self, user_tier: &str) -> Result<(), StatusCode> {
        let limiter = self.get_limiter(user_tier, "default");
        match limiter.check() {
            Ok(_) => Ok(()),
            Err(_) => Err(StatusCode::TOO_MANY_REQUESTS),
        }
    }
}
```

2. **Add rate limit middleware**:
```rust
pub async fn rate_limit_middleware(
    State(state): State<Arc<AppState>>,
    req: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let auth_context = req.extensions().get::<AuthContext>();
    
    let user_tier = auth_context
        .map(|ctx| {
            if ctx.roles.contains(&"premium".to_string()) {
                "premium"
            } else {
                "user"
            }
        })
        .unwrap_or("anonymous");
    
    state.rate_limiter.check_rate_limit(user_tier)?;
    Ok(next.run(req).await)
}
```

#### Success Criteria
- [ ] Rate limiting functions correctly for all user tiers
- [ ] HTTP 429 responses for exceeded limits
- [ ] Rate limit headers in responses

---

### üü° SEC-004: HTTPS/TLS Implementation

**Target**: Enforce TLS for all connections  
**Priority**: P1 - High  
**Effort**: 2 days  

#### Implementation Steps

1. **Add TLS configuration**:
```rust
// In crates/codegraph-core/src/config.rs
#[derive(Deserialize, Clone)]
pub struct TlsConfig {
    pub cert_path: String,
    pub key_path: String,
    pub require_tls: bool,
}

#[derive(Deserialize, Clone)]  
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
    pub tls: Option<TlsConfig>,
}
```

2. **Update server implementation**:
```rust
// In crates/codegraph-api/src/server.rs
use axum_server::tls_rustls::RustlsConfig;

impl Server {
    pub async fn run(self) -> Result<()> {
        let router = create_router(self.state);
        
        if let Some(tls_config) = &self.config.server().tls {
            info!("Starting HTTPS server on https://{}", self.addr);
            let config = RustlsConfig::from_pem_file(&tls_config.cert_path, &tls_config.key_path)
                .await
                .map_err(|e| codegraph_core::CodeGraphError::Config(e.to_string()))?;
            
            axum_server::bind_rustls(self.addr, config)
                .serve(router.into_make_service())
                .with_graceful_shutdown(shutdown_signal())
                .await
                .map_err(|e| codegraph_core::CodeGraphError::Io(e.into()))?;
        } else {
            warn!("Running in HTTP mode - not recommended for production");
            // Existing HTTP implementation
        }
        
        Ok(())
    }
}
```

#### Success Criteria
- [ ] TLS certificates loaded and validated
- [ ] HTTPS enforced in production mode
- [ ] Proper cipher suite configuration
- [ ] HSTS headers implemented

---

### üü° SEC-005: Input Validation Framework

**Target**: Comprehensive input validation  
**Priority**: P1 - High  
**Effort**: 3 days  

#### Implementation Steps

1. **Create validation framework**:
```rust
// In crates/codegraph-core/src/validation.rs
use regex::Regex;
use std::path::Path;

pub trait Validate {
    fn validate(&self) -> Result<(), ValidationError>;
}

#[derive(Debug)]
pub enum ValidationError {
    InvalidFormat(String),
    InvalidLength { field: String, min: usize, max: usize },
    PathTraversal(String),
    InvalidCharacters(String),
}

pub struct FilePathValidator;

impl FilePathValidator {
    pub fn validate_file_path(path: &str) -> Result<(), ValidationError> {
        // Check for path traversal attempts
        if path.contains("..") || path.contains("~") {
            return Err(ValidationError::PathTraversal(path.to_string()));
        }
        
        // Validate path components
        let path_obj = Path::new(path);
        if !path_obj.is_relative() && !path_obj.starts_with("/app/data") {
            return Err(ValidationError::PathTraversal(path.to_string()));
        }
        
        // Check for dangerous characters
        lazy_static! {
            static ref SAFE_PATH_REGEX: Regex = 
                Regex::new(r"^[a-zA-Z0-9._/\-]+$").unwrap();
        }
        
        if !SAFE_PATH_REGEX.is_match(path) {
            return Err(ValidationError::InvalidCharacters(path.to_string()));
        }
        
        Ok(())
    }
}

pub struct QueryValidator;

impl QueryValidator {
    pub fn validate_search_query(query: &str) -> Result<(), ValidationError> {
        if query.len() > 1000 {
            return Err(ValidationError::InvalidLength { 
                field: "query".to_string(), 
                min: 1, 
                max: 1000 
            });
        }
        
        // Check for SQL injection patterns
        let dangerous_patterns = ["'", "\"", ";", "--", "/*", "*/", "xp_", "sp_"];
        for pattern in &dangerous_patterns {
            if query.to_lowercase().contains(pattern) {
                return Err(ValidationError::InvalidCharacters(
                    format!("Query contains dangerous pattern: {}", pattern)
                ));
            }
        }
        
        Ok(())
    }
}
```

2. **Update handlers with validation**:
```rust
// In crates/codegraph-api/src/handlers.rs
use codegraph_core::validation::{FilePathValidator, QueryValidator};

pub async fn parse_file(
    State(state): State<AppState>,
    Json(request): Json<ParseRequest>,
) -> ApiResult<Json<ParseResponse>> {
    // Validate file path
    FilePathValidator::validate_file_path(&request.file_path)
        .map_err(|e| ApiError::BadRequest(format!("Invalid file path: {:?}", e)))?;
    
    // Rest of implementation...
}

pub async fn search_nodes(
    State(state): State<AppState>,
    Query(params): Query<SearchQuery>,
) -> ApiResult<Json<SearchResponse>> {
    // Validate search query
    QueryValidator::validate_search_query(&params.query)
        .map_err(|e| ApiError::BadRequest(format!("Invalid query: {:?}", e)))?;
    
    // Rest of implementation...
}
```

#### Success Criteria
- [ ] All user inputs validated before processing
- [ ] Path traversal attacks prevented
- [ ] SQL injection patterns blocked
- [ ] Input length limits enforced

---

### üü° SEC-006: Administrative Endpoint Security

**Target**: Secure admin endpoints with proper access control  
**Priority**: P1 - High  
**Effort**: 1 day  

#### Implementation Steps

1. **Add admin guard**:
```rust
// In crates/codegraph-api/src/auth.rs
pub struct AdminGuard;

impl Guard for AdminGuard {
    async fn check(&self, ctx: &Context<'_>) -> Result<()> {
        let auth_context = ctx.data_opt::<AuthContext>()
            .ok_or_else(|| "Authentication required")?;
            
        if !AuthorizationEngine::has_permission(auth_context, &[Permission::ADMIN_SYSTEM]) {
            return Err("Administrator access required".into());
        }
        
        Ok(())
    }
}
```

2. **Secure admin endpoints**:
```rust
// Update handlers.rs admin endpoints
#[cfg(feature = "leak-detect")]
pub async fn memory_stats(
    auth: AuthContext,
) -> ApiResult<Json<MemoryStatsResponse>> {
    // Verify admin permissions
    if !AuthorizationEngine::has_permission(&auth, &[Permission::ADMIN_SYSTEM]) {
        return Err(ApiError::Forbidden);
    }
    
    // Rest of implementation...
}
```

#### Success Criteria
- [ ] Admin endpoints require ADMIN_SYSTEM permission
- [ ] Unauthorized access returns 403 Forbidden
- [ ] Admin access logged for audit

---

### üü° SEC-007: Security Headers Implementation

**Target**: Comprehensive security headers  
**Priority**: P1 - High  
**Effort**: 1 day  

#### Implementation Steps

1. **Create security headers middleware**:
```rust
// In crates/codegraph-api/src/middleware/security.rs
use axum::{
    http::{header, HeaderValue, StatusCode},
    middleware::Next,
    response::Response,
    extract::Request,
};

pub async fn security_headers_middleware(
    req: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let mut response = next.run(req).await;
    
    let headers = response.headers_mut();
    
    // HSTS
    headers.insert(
        header::STRICT_TRANSPORT_SECURITY,
        HeaderValue::from_static("max-age=31536000; includeSubDomains; preload"),
    );
    
    // CSP
    headers.insert(
        header::CONTENT_SECURITY_POLICY,
        HeaderValue::from_static("default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'"),
    );
    
    // X-Frame-Options
    headers.insert(
        "X-Frame-Options".parse().unwrap(),
        HeaderValue::from_static("DENY"),
    );
    
    // X-Content-Type-Options
    headers.insert(
        "X-Content-Type-Options".parse().unwrap(),
        HeaderValue::from_static("nosniff"),
    );
    
    // X-XSS-Protection
    headers.insert(
        "X-XSS-Protection".parse().unwrap(),
        HeaderValue::from_static("1; mode=block"),
    );
    
    // Referrer-Policy
    headers.insert(
        "Referrer-Policy".parse().unwrap(),
        HeaderValue::from_static("strict-origin-when-cross-origin"),
    );
    
    Ok(response)
}
```

#### Success Criteria
- [ ] All security headers present in responses
- [ ] CSP policy blocks unauthorized resources
- [ ] HSTS enforces HTTPS
- [ ] X-Frame-Options prevents clickjacking

---

## Minor Issues Remediation (Week 4)

### üîµ SEC-008: Secure Service Account UUIDs

**Implementation**: Generate unique UUIDs for service accounts
**Effort**: 2 hours

### üîµ SEC-009: Sanitized Error Responses

**Implementation**: Create error response sanitization
**Effort**: 4 hours

## Testing and Validation

### Security Testing Suite

1. **Authentication Tests**:
```bash
# Test JWT validation
curl -H "Authorization: Bearer invalid_token" http://localhost:8080/nodes
# Should return 401

# Test API key validation
curl -H "X-API-KEY: invalid_key" http://localhost:8080/nodes
# Should return 401
```

2. **Input Validation Tests**:
```bash
# Test path traversal protection
curl -X POST -H "Content-Type: application/json" \
  -d '{"file_path":"../../../etc/passwd"}' \
  http://localhost:8080/parse
# Should return 400 with validation error

# Test query injection protection  
curl "http://localhost:8080/search?query=test';DROP TABLE users;--"
# Should return 400 with validation error
```

3. **Rate Limiting Tests**:
```bash
# Test rate limiting (run multiple times quickly)
for i in {1..100}; do curl http://localhost:8080/health; done
# Should eventually return 429
```

## Continuous Security Monitoring

### Automated Security Checks

1. **CI/CD Security Pipeline**:
```yaml
# .github/workflows/security.yml
name: Security Checks
on: [push, pull_request]
jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install Rust
        uses: actions-rs/toolchain@v1
      - name: Install cargo-audit
        run: cargo install cargo-audit
      - name: Run security audit
        run: cargo audit
      - name: Run clippy security lints
        run: cargo clippy -- -D clippy::suspicious
```

2. **Dependency Monitoring**:
```bash
# Regular dependency security checks
cargo audit --db /tmp/advisory-db
cargo outdated
```

### Security Metrics and Alerting

1. **Security Event Logging**:
```rust
// Add to authentication middleware
use tracing::{warn, info};

// Log authentication failures
warn!(
    user_id = %attempted_user,
    ip_address = %client_ip,
    "Authentication failure: invalid JWT token"
);

// Log admin access
info!(
    user_id = %auth_context.user_id,
    action = "admin_access",
    endpoint = %req.uri(),
    "Administrator accessed sensitive endpoint"
);
```

2. **Prometheus Security Metrics**:
```rust
// Add security metrics
lazy_static! {
    static ref AUTH_FAILURES: Counter = Counter::new(
        "auth_failures_total", "Total authentication failures"
    ).unwrap();
    
    static ref ADMIN_ACCESS: Counter = Counter::new(
        "admin_access_total", "Total admin endpoint access"
    ).unwrap();
}
```

## Success Criteria and Acceptance Testing

### Critical Issues Resolution
- [ ] All `cargo audit` vulnerabilities resolved
- [ ] JWT secrets loaded from environment variables
- [ ] API keys managed through secure system
- [ ] HTTPS enforced in production configuration

### Major Issues Resolution  
- [ ] Rate limiting functional with proper error responses
- [ ] All inputs validated and sanitized
- [ ] Security headers present in all responses
- [ ] Admin endpoints require proper authorization

### Security Testing
- [ ] Penetration testing passes for all critical areas
- [ ] Authentication/authorization bypass attempts fail
- [ ] Input validation prevents injection attacks
- [ ] TLS configuration rated A+ by SSL Labs

### Compliance
- [ ] OWASP Top 10 compliance achieved
- [ ] Security logging implemented
- [ ] Incident response procedures documented
- [ ] Regular security review schedule established

## Risk Assessment Post-Remediation

### Residual Risks
- **Low**: Minor information disclosure through verbose logging
- **Low**: DoS through resource exhaustion (requires monitoring)
- **Medium**: Social engineering attacks on API key management

### Ongoing Security Requirements
1. **Regular security audits** (quarterly)
2. **Dependency vulnerability monitoring** (automated)  
3. **Penetration testing** (annual)
4. **Security training** for development team
5. **Incident response procedures** and testing

---

**Plan Status**: Ready for Implementation  
**Next Review**: After Week 2 milestone  
**Approval Required**: Security Team Lead, DevOps Manager